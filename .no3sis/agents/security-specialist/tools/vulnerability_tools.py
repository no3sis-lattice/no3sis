"""
Vulnerability scanning and detection tools for security analysis.
"""

import asyncio
import json
import os
import re
from pathlib import Path
from typing import Dict, List, Any, Optional
import subprocess


async def scan_vulnerabilities(target_path: str = ".", scan_type: str = "comprehensive") -> Dict[str, Any]:
    """
    Scan codebase for security vulnerabilities using multiple detection methods.

    Args:
        target_path: Path to scan (default: current directory)
        scan_type: Type of scan - "quick", "comprehensive", "dependency-only"

    Returns:
        Dict containing vulnerability findings organized by severity
    """
    results = {
        "critical": [],
        "high": [],
        "medium": [],
        "low": [],
        "info": [],
        "scan_metadata": {
            "target": target_path,
            "scan_type": scan_type,
            "timestamp": "",
            "tools_used": []
        }
    }

    try:
        # Detect secrets and credentials
        secrets = await detect_secrets(target_path)
        if secrets["findings"]:
            results["critical"].extend(secrets["findings"])

        # Check for dependency vulnerabilities
        deps = await analyze_dependencies(target_path)
        for vuln in deps["vulnerabilities"]:
            severity = vuln.get("severity", "medium").lower()
            if severity in results:
                results[severity].append(vuln)

        # Scan for OWASP Top 10 patterns
        owasp_results = await check_owasp_compliance(target_path)
        for category, findings in owasp_results.items():
            if findings:
                results["high"].extend(findings)

        results["scan_metadata"]["tools_used"] = ["secret_scanner", "dependency_checker", "owasp_scanner"]

    except Exception as e:
        results["scan_metadata"]["error"] = str(e)

    return results


async def analyze_dependencies(project_path: str = ".") -> Dict[str, Any]:
    """
    Analyze project dependencies for known vulnerabilities.

    Args:
        project_path: Path to project with dependency files

    Returns:
        Dict with vulnerability analysis results
    """
    results = {
        "vulnerabilities": [],
        "outdated_packages": [],
        "license_issues": [],
        "recommendations": []
    }

    # Check for common dependency files
    dependency_files = [
        "package.json", "package-lock.json",  # Node.js
        "requirements.txt", "Pipfile", "pyproject.toml",  # Python
        "Cargo.toml", "Cargo.lock",  # Rust
        "go.mod", "go.sum",  # Go
        "pom.xml", "build.gradle"  # Java
    ]

    found_files = []
    for dep_file in dependency_files:
        file_path = Path(project_path) / dep_file
        if file_path.exists():
            found_files.append(dep_file)

    # Simulate vulnerability scanning for each ecosystem
    for dep_file in found_files:
        if "package" in dep_file:
            results["recommendations"].append("Run 'npm audit' for Node.js vulnerability scanning")
        elif any(py in dep_file for py in ["requirements", "Pipfile", "pyproject"]):
            results["recommendations"].append("Run 'safety check' or 'pip-audit' for Python vulnerabilities")
        elif "Cargo" in dep_file:
            results["recommendations"].append("Run 'cargo audit' for Rust dependency vulnerabilities")
        elif "go." in dep_file:
            results["recommendations"].append("Run 'govulncheck' for Go vulnerability scanning")

    if not found_files:
        results["recommendations"].append("No dependency files detected. Ensure proper dependency management.")

    return results


async def check_owasp_compliance(target_path: str = ".") -> Dict[str, List[Dict[str, Any]]]:
    """
    Check code for OWASP Top 10 vulnerability patterns.

    Args:
        target_path: Path to analyze

    Returns:
        Dict mapping OWASP categories to found issues
    """
    owasp_patterns = {
        "A01_Broken_Access_Control": [
            r"admin\s*=\s*true",
            r"role\s*==\s*['\"]admin['\"]",
            r"if\s*\(\s*user\.isAdmin\s*\)",
        ],
        "A02_Cryptographic_Failures": [
            r"MD5|SHA1(?!256|384|512)",
            r"DES(?!ede)|RC4",
            r"password\s*=\s*['\"][^'\"]*['\"]",
        ],
        "A03_Injection": [
            r"execute\s*\([^)]*\+[^)]*\)",
            r"eval\s*\([^)]*\+[^)]*\)",
            r"SELECT.*\+.*FROM",
        ],
        "A04_Insecure_Design": [
            r"TODO:\s*security",
            r"FIXME:\s*auth",
            r"# HACK:",
        ],
        "A05_Security_Misconfiguration": [
            r"debug\s*=\s*True",
            r"DEBUG\s*=\s*true",
            r"cors\s*:\s*\*",
        ],
        "A06_Vulnerable_Components": [],  # Handled by dependency analysis
        "A07_Identity_Auth_Failures": [
            r"password\s*==\s*['\"]",
            r"token\s*=\s*['\"][^'\"]{1,10}['\"]",
            r"session_timeout\s*=\s*[0-9]{7,}",
        ],
        "A08_Software_Data_Integrity": [
            r"pickle\.loads",
            r"yaml\.load(?!\s*\(.*Loader)",
            r"eval\s*\(",
        ],
        "A09_Security_Logging_Monitoring": [
            r"except.*pass\s*$",
            r"try:.*except:.*pass",
            r"print\s*\(.*password",
        ],
        "A10_Server_Side_Request_Forgery": [
            r"requests\.get\s*\([^)]*user",
            r"urllib\.request\.urlopen\s*\([^)]*user",
            r"fetch\s*\([^)]*user",
        ]
    }

    results = {}

    try:
        # Scan files for patterns
        for root, dirs, files in os.walk(target_path):
            # Skip common non-source directories
            dirs[:] = [d for d in dirs if d not in ['.git', 'node_modules', '__pycache__', '.venv']]

            for file in files:
                if file.endswith(('.py', '.js', '.ts', '.java', '.go', '.rs', '.php')):
                    file_path = Path(root) / file
                    try:
                        content = file_path.read_text(encoding='utf-8')

                        for category, patterns in owasp_patterns.items():
                            if category not in results:
                                results[category] = []

                            for pattern in patterns:
                                matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
                                for match in matches:
                                    line_num = content[:match.start()].count('\n') + 1
                                    results[category].append({
                                        "file": str(file_path),
                                        "line": line_num,
                                        "pattern": pattern,
                                        "match": match.group(0),
                                        "severity": "high",
                                        "recommendation": f"Review {category.replace('_', ' ')} pattern"
                                    })

                    except UnicodeDecodeError:
                        continue  # Skip binary files

    except Exception as e:
        results["scan_error"] = str(e)

    return results


async def detect_secrets(target_path: str = ".") -> Dict[str, Any]:
    """
    Detect hardcoded secrets, API keys, and credentials in code.

    Args:
        target_path: Path to scan

    Returns:
        Dict with detected secrets and recommendations
    """
    secret_patterns = {
        "api_keys": [
            r"api[_-]?key\s*[:=]\s*['\"][a-zA-Z0-9]{16,}['\"]",
            r"apikey\s*[:=]\s*['\"][a-zA-Z0-9]{16,}['\"]",
        ],
        "tokens": [
            r"token\s*[:=]\s*['\"][a-zA-Z0-9._-]{20,}['\"]",
            r"bearer\s+[a-zA-Z0-9._-]{20,}",
        ],
        "passwords": [
            r"password\s*[:=]\s*['\"][^'\"]{8,}['\"]",
            r"passwd\s*[:=]\s*['\"][^'\"]{8,}['\"]",
        ],
        "database_urls": [
            r"(?:postgres|mysql|mongodb)://[^@]+:[^@]+@[^/]+",
            r"jdbc:[^:]+://[^:]+:[^@]+@[^/]+",
        ],
        "cloud_credentials": [
            r"AKIA[0-9A-Z]{16}",  # AWS Access Key
            r"sk-[a-zA-Z0-9]{48}",  # OpenAI API Key
            r"xox[baprs]-[a-zA-Z0-9-]+",  # Slack tokens
        ]
    }

    findings = []

    try:
        for root, dirs, files in os.walk(target_path):
            # Skip sensitive directories
            dirs[:] = [d for d in dirs if d not in ['.git', 'node_modules', '__pycache__', '.venv']]

            for file in files:
                # Skip binary and large files
                if file.endswith(('.py', '.js', '.ts', '.json', '.yaml', '.yml', '.env', '.config')):
                    file_path = Path(root) / file
                    try:
                        if file_path.stat().st_size > 1024 * 1024:  # Skip files > 1MB
                            continue

                        content = file_path.read_text(encoding='utf-8')

                        for category, patterns in secret_patterns.items():
                            for pattern in patterns:
                                matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
                                for match in matches:
                                    line_num = content[:match.start()].count('\n') + 1
                                    findings.append({
                                        "type": category,
                                        "file": str(file_path),
                                        "line": line_num,
                                        "pattern": pattern,
                                        "severity": "critical",
                                        "recommendation": f"Move {category} to secure environment variables or vault"
                                    })

                    except (UnicodeDecodeError, PermissionError):
                        continue

    except Exception as e:
        return {"error": str(e), "findings": []}

    return {
        "findings": findings,
        "total_secrets": len(findings),
        "recommendations": [
            "Use environment variables for sensitive data",
            "Implement proper secret management (HashiCorp Vault, AWS Secrets Manager)",
            "Add .env files to .gitignore",
            "Use pre-commit hooks to prevent secret commits",
            "Rotate any exposed credentials immediately"
        ]
    }


async def audit_permissions(target_path: str = ".") -> Dict[str, Any]:
    """
    Audit file permissions and access controls.

    Args:
        target_path: Path to audit

    Returns:
        Dict with permission analysis results
    """
    results = {
        "excessive_permissions": [],
        "world_writable": [],
        "executable_configs": [],
        "recommendations": []
    }

    try:
        for root, dirs, files in os.walk(target_path):
            for item in files + dirs:
                item_path = Path(root) / item
                if item_path.exists():
                    stat = item_path.stat()
                    mode = stat.st_mode

                    # Check for world-writable files
                    if mode & 0o002:
                        results["world_writable"].append({
                            "path": str(item_path),
                            "permissions": oct(mode)[-3:],
                            "severity": "high"
                        })

                    # Check for executable config files
                    if item.endswith(('.config', '.conf', '.ini', '.yaml', '.yml', '.json')) and mode & 0o111:
                        results["executable_configs"].append({
                            "path": str(item_path),
                            "permissions": oct(mode)[-3:],
                            "severity": "medium"
                        })

        # Add recommendations
        if results["world_writable"]:
            results["recommendations"].append("Remove world-write permissions from sensitive files")
        if results["executable_configs"]:
            results["recommendations"].append("Remove execute permissions from configuration files")

        results["recommendations"].append("Follow principle of least privilege for file permissions")

    except Exception as e:
        results["error"] = str(e)

    return results


async def validate_security_headers(config_files: List[str] = None) -> Dict[str, Any]:
    """
    Validate security headers in web application configuration.

    Args:
        config_files: List of configuration files to check

    Returns:
        Dict with security header validation results
    """
    if config_files is None:
        config_files = []

    required_headers = {
        "Content-Security-Policy": {
            "importance": "critical",
            "description": "Prevents XSS and injection attacks"
        },
        "X-Frame-Options": {
            "importance": "high",
            "description": "Prevents clickjacking attacks"
        },
        "X-Content-Type-Options": {
            "importance": "medium",
            "description": "Prevents MIME type sniffing"
        },
        "Strict-Transport-Security": {
            "importance": "high",
            "description": "Enforces HTTPS connections"
        },
        "Referrer-Policy": {
            "importance": "medium",
            "description": "Controls referrer information"
        }
    }

    results = {
        "missing_headers": [],
        "weak_configurations": [],
        "recommendations": []
    }

    # Check common web server configs
    config_patterns = {
        "nginx": ["nginx.conf", "default.conf"],
        "apache": [".htaccess", "httpd.conf"],
        "express": ["app.js", "server.js"],
        "django": ["settings.py"]
    }

    for server_type, patterns in config_patterns.items():
        for pattern in patterns:
            if any(pattern in f for f in config_files):
                results["recommendations"].append(f"Review {server_type} security header configuration")

    # Add general recommendations
    for header, info in required_headers.items():
        results["missing_headers"].append({
            "header": header,
            "importance": info["importance"],
            "description": info["description"]
        })

    results["recommendations"].extend([
        "Implement all critical security headers",
        "Test headers using online security scanners",
        "Use security-focused middleware/modules",
        "Regularly audit and update security policies"
    ])

    return results