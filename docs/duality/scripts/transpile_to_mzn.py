#!/usr/bin/env python3
"""
JSON→MiniZinc Transpiler for Synapse Duality Formalization
Phase 3: Automated constraint translation with operator mapping

Usage:
  python3 transpile_to_mzn.py --chunk 06
  python3 transpile_to_mzn.py --all
  python3 transpile_to_mzn.py --chunk 06 --output chunk-06.mzn
"""

import argparse
import json
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional

# Import shared utilities (Phase 2.1)
# Note: Only load_doc_chunks and get_base_duality_dir exist in shared_utils.py
# Other utilities are defined locally in this file


# Operator mapping: JSON DSL → MiniZinc
OPERATOR_MAP = {
    '%': 'mod',
    '&&': r'/\\',
    '||': r'\/',
    '!': 'not ',
    '==': '=',
    '!=': '!=',
}

# Function mapping
FUNCTION_MAP = {
    'abs': 'abs',
    'sum': 'sum',
    'forall': 'forall',
    'exists': 'exists',
    'count': 'sum',  # count(i in S)(P) → sum(i in S)(bool2int(P))
}


def sanitize_meta_constructs_mzn(expr: str) -> str:
    """
    PHASE 5.5: Sanitize meta-level constructs for MiniZinc.

    Removes unsupported symbolic/meta constructs:
    - typeof(...), component_of(...), pipeline(...), well_formed(...)
    - set cardinality |{...}|
    - non-numeric membership (x ∈ S)

    Returns 'true' if expression becomes empty after sanitization.
    """
    result = expr.strip()

    # Remove meta predicates - replace with 'true'
    meta_patterns = [
        r'\btypeof\s*\([^)]*\)',
        r'\bcomponent_of\s*\([^)]*\)',
        r'\bpipeline\s*\([^)]*\)',
        r'\bwell_formed\s*\([^)]*\)',
        r'\bhas_field\s*\([^)]*\)',
    ]

    for pattern in meta_patterns:
        result = re.sub(pattern, 'true', result)

    # Remove set cardinality notation |{...}| = N
    result = re.sub(r'\|\s*\{[^}]*\}\s*\|\s*[=<>!]+\s*\d+', 'true', result)

    # Remove symbolic membership (x ∈ {symbolic_set})
    # Keep numeric ranges like "i in 1..8" which are valid
    result = re.sub(r'\w+\s*∈\s*\{[^}]*\}', 'true', result)
    result = result.replace('∈', ' in ')

    # Clean up: if multiple 'true' with operators, simplify
    # true && X → X, X && true → X
    result = re.sub(r'true\s*/\\\s*', '', result)
    result = re.sub(r'\s*/\\\s*true', '', result)

    # If entirely empty or just whitespace, return 'true'
    if not result.strip() or result.strip() == '&&' or result.strip() == '/\\':
        return 'true'

    return result


def translate_expr_to_mzn(expr: str) -> str:
    """
    Translate JSON DSL expression to MiniZinc syntax.

    Handles:
    - Operator mapping (%, &&, ||, !, ==)
    - Array indexing: x[1] stays x[1]
    - sum(i in 1..4)(x[i]) stays sum(i in 1..4)(x[i])
    - forall(i in 1..4)(x[i] >= 3) stays forall(i in 1..4)(x[i] >= 3)
    - count(i in S)(P) → sum(i in S)(bool2int(P)) with implicit coercion
    - PHASE 5.5: Sanitizes meta constructs (typeof, component_of, etc.)
    """
    # PHASE 5.5: Sanitize meta constructs FIRST
    result = sanitize_meta_constructs_mzn(expr)

    # Replace operators (order matters for precedence)
    # Must handle && before & and || before |
    result = result.replace('&&', '/\\')
    result = result.replace('||', '\\/')

    # Replace negation (! followed by space or parenthesis)
    result = re.sub(r'!(\s*\()', r'not \1', result)
    result = re.sub(r'!(\s*[a-zA-Z])', r'not \1', result)

    # Replace modulo
    result = re.sub(r'\s*%\s*', ' mod ', result)

    # Replace equality (== → =, but != stays !=)
    result = re.sub(r'([^!<>])===?([^=])', r'\1=\2', result)

    # Handle count() by converting to sum with implicit bool→int coercion
    # count(i in 1..8)(x[i] > 0) → sum(i in 1..8)(x[i] > 0)
    # MiniZinc does implicit bool2int in arithmetic contexts
    result = re.sub(r'\bcount\s*\(', 'sum(', result)

    # Handle true/false literals
    result = re.sub(r'\btrue\b', 'true', result, flags=re.IGNORECASE)
    result = re.sub(r'\bfalse\b', 'false', result, flags=re.IGNORECASE)

    return result.strip()


def generate_mzn_header(params: Dict) -> List[str]:
    """Generate MiniZinc header with parameters."""
    lines = [
        "% MiniZinc model for 8D unit-sum manifold + Monster primes",
        "% Auto-generated by transpile_to_mzn.py",
        "",
        "% Parameters",
    ]

    scale_n = params.get("scaleN", 100)
    lines.append(f"int: N = {scale_n};  % sum(x[i]) = N (discrete unitary)")

    monster_primes = params.get("monsterPrimes", [2, 3, 5, 7, 11, 13, 17, 19])
    primes_str = ", ".join(str(p) for p in monster_primes)
    lines.append(f"set of int: P = {{ {primes_str} }};  % Monster primes subset")

    lines.extend([
        "",
        "% Decision variables: 8D coordinates",
        "array[1..8] of var 0..N: x;",
        "",
        "% Unit-sum constraint",
        "constraint sum(i in 1..8)(x[i]) = N;",
        "",
    ])

    return lines


def generate_mzn_constraints(constraints: List[Dict]) -> List[str]:
    """Generate MiniZinc constraint declarations."""
    lines = ["% Domain-specific constraints"]

    for c in constraints:
        name = c.get("name", "unnamed")
        expr = c.get("expr", "true")
        notes = c.get("notes", "")

        # Add name annotation as comment
        lines.append(f"% constraint: {name}")

        # Translate expression
        mzn_expr = translate_expr_to_mzn(expr)
        lines.append(f"constraint {mzn_expr};")

        # Add notes as comment if present
        if notes:
            lines.append(f"% {notes}")

        lines.append("")  # Blank line between constraints

    return lines


def inject_ipv6_encoding(params: Dict) -> List[str]:
    """
    Phase 5: Inject IPv6 encoding template for pilot demo (Chunk 06 only).

    Reads templates/ipv6_encode.mzn and injects its content, which:
    - Maps 8D coordinates x[1..8] to 8x 16-bit hextets (IPv6 address components)
    - Scales x[i] values (0..N) into hextet range (0..65535)
    - Embeds Monster prime bitmask in the last hextet

    This is a demo feature showing numogrammatic encoding potential.
    """
    lines = [
        "",
        "% ═══════════════════════════════════════════════════════════════",
        "% Phase 5: IPv6 Encoding (Pilot Demo - Chunk 06 only)",
        "% ═══════════════════════════════════════════════════════════════",
        "",
    ]

    # Read IPv6 template from templates/ directory
    template_path = Path(__file__).resolve().parents[1] / "templates" / "ipv6_encode.mzn"

    if not template_path.exists():
        lines.append("% WARNING: IPv6 template not found at {template_path}")
        return lines

    try:
        template_content = template_path.read_text(encoding="utf-8")

        # Skip the first few lines (header comments and parameter declarations already defined)
        # Only inject the actual encoding logic (hextet array and constraints)
        template_lines = template_content.split("\n")

        # Find where actual logic starts (after parameter declarations)
        inject_start = 0
        for i, line in enumerate(template_lines):
            if "array[1..8] of var 0..65535: hextet" in line:
                inject_start = i
                break

        if inject_start > 0:
            # Inject from hextet array declaration onwards, but skip duplicate declarations
            lines.append("% IPv6 hextet encoding (maps x[1..8] → 8x 16-bit hextets)")
            for line in template_lines[inject_start:]:
                # Skip duplicate parameter declarations (N, P, x already defined in header)
                if re.match(r'^\s*(int: N|set of int: P|array\[1\.\.8\] of var 0\.\.N: x)\s*[;=]', line):
                    continue  # Skip duplicate
                lines.append(line)
        else:
            # Fallback: inject entire template
            lines.append("% IPv6 encoding template (full injection)")
            lines.extend(template_lines)

    except Exception as e:
        lines.append(f"% ERROR reading IPv6 template: {e}")

    lines.extend([
        "",
        "% ═══════════════════════════════════════════════════════════════",
        "",
    ])

    return lines


def generate_mzn_footer(params: Dict) -> List[str]:
    """Generate MiniZinc footer with objective."""
    lines = []

    similarity_obj = params.get("similarityObjective", "none")

    if similarity_obj == "none":
        lines.extend([
            "% No optimization objective",
            "solve satisfy;",
        ])
    elif similarity_obj == "neighbor_distance_min":
        lines.extend([
            "% Minimize neighbor distance (requires adjacency specification)",
            "% var int: total_distance;",
            "% constraint total_distance = ...; % Define based on chunk semantics",
            "% solve minimize total_distance;",
            "solve satisfy;  % Fallback to satisfaction",
        ])
    else:
        lines.extend([
            f"% Objective: {similarity_obj}",
            "solve satisfy;",
        ])

    return lines


def generate_mzn_from_json(json_data: Dict, with_ipv6: bool = False, chunk_id: str = None) -> str:
    """
    Generate complete MiniZinc model from JSON constraints.

    Phase 5: Optional IPv6 encoding for Chunk 06 pilot demo.

    Args:
        json_data: Chunk JSON data
        with_ipv6: If True and chunk_id=="06", include IPv6 encoding template
        chunk_id: Chunk ID (e.g., "06") for selective IPv6 injection

    Returns:
        Complete MiniZinc model as string
    """
    params = json_data.get("parameters", {})
    constraints = json_data.get("constraints", [])

    lines = []
    lines.extend(generate_mzn_header(params))

    # Phase 5: Inject IPv6 encoding template for Chunk 06 when flag enabled
    if with_ipv6 and chunk_id == "06":
        lines.extend(inject_ipv6_encoding(params))

    lines.extend(generate_mzn_constraints(constraints))
    lines.extend(generate_mzn_footer(params))

    return "\n".join(lines)


def process_chunk(chunk_id: str, base_dir: Path, output_path: Optional[Path] = None) -> bool:
    """Process a single chunk and generate MiniZinc model."""
    # Load JSON using shared utility
    json_path = get_chunk_json_path(chunk_id, base_dir)
    json_data = load_json_safe(json_path)

    if json_data is None:
        return False

    # Generate MiniZinc
    mzn_content = generate_mzn_from_json(json_data)

    # Determine output path
    if output_path is None:
        output_path = get_chunk_mzn_path(chunk_id, base_dir)

    # Write output
    try:
        output_path.write_text(mzn_content, encoding="utf-8")
        print(f"Generated: {output_path}")
        return True
    except Exception as e:
        print(f"Error writing {output_path}: {e}", file=sys.stderr)
        return False


def main(argv: Optional[List[str]] = None) -> int:
    parser = argparse.ArgumentParser(
        description="Transpile JSON constraint DSL to MiniZinc"
    )

    default_base = Path(__file__).resolve().parents[1]
    parser.add_argument(
        "--base-dir",
        type=Path,
        default=default_base,
        help=f"Base duality directory (default: {default_base})"
    )
    parser.add_argument(
        "--chunk",
        type=str,
        help="Chunk ID to process (e.g., 06)"
    )
    parser.add_argument(
        "--all",
        action="store_true",
        help="Process all discovered chunks"
    )
    parser.add_argument(
        "--output",
        type=Path,
        help="Output path (default: chunk-{id}.mzn in chunks dir)"
    )

    args = parser.parse_args(argv)

    if not args.chunk and not args.all:
        parser.error("Must specify --chunk or --all")

    base_dir = args.base_dir

    if args.all:
        chunk_ids = discover_chunks(base_dir)
        if not chunk_ids:
            print("No chunks discovered", file=sys.stderr)
            return 1

        success_count = 0
        for cid in chunk_ids:
            if process_chunk(cid, base_dir):
                success_count += 1

        print(f"\nProcessed {success_count}/{len(chunk_ids)} chunks successfully")
        return 0 if success_count == len(chunk_ids) else 1

    else:
        # Process single chunk
        chunk_id = f"{int(args.chunk):02d}"
        success = process_chunk(chunk_id, base_dir, args.output)
        return 0 if success else 1


if __name__ == "__main__":
    raise SystemExit(main())
