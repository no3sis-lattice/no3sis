#!/usr/bin/env python3
"""
JSON→MiniZinc Transpiler for Synapse Duality Formalization
Phase 3: Automated constraint translation with operator mapping

Usage:
  python3 transpile_to_mzn.py --chunk 06
  python3 transpile_to_mzn.py --all
  python3 transpile_to_mzn.py --chunk 06 --output chunk-06.mzn
"""

import argparse
import json
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional


# Operator mapping: JSON DSL → MiniZinc
OPERATOR_MAP = {
    '%': 'mod',
    '&&': r'/\\',
    '||': r'\/',
    '!': 'not ',
    '==': '=',
    '!=': '!=',
}

# Function mapping
FUNCTION_MAP = {
    'abs': 'abs',
    'sum': 'sum',
    'forall': 'forall',
    'exists': 'exists',
    'count': 'sum',  # count(i in S)(P) → sum(i in S)(bool2int(P))
}


def translate_expr_to_mzn(expr: str) -> str:
    """
    Translate JSON DSL expression to MiniZinc syntax.

    Handles:
    - Operator mapping (%, &&, ||, !, ==)
    - Array indexing: x[1] stays x[1]
    - sum(i in 1..4)(x[i]) stays sum(i in 1..4)(x[i])
    - forall(i in 1..4)(x[i] >= 3) stays forall(i in 1..4)(x[i] >= 3)
    - count(i in S)(P) → sum(i in S)(bool2int(P)) with implicit coercion
    """
    result = expr

    # Replace operators (order matters for precedence)
    # Must handle && before & and || before |
    result = result.replace('&&', '/\\')
    result = result.replace('||', '\\/')

    # Replace negation (! followed by space or parenthesis)
    result = re.sub(r'!(\s*\()', r'not \1', result)
    result = re.sub(r'!(\s*[a-zA-Z])', r'not \1', result)

    # Replace modulo
    result = re.sub(r'\s*%\s*', ' mod ', result)

    # Replace equality (== → =, but != stays !=)
    result = re.sub(r'([^!<>])===?([^=])', r'\1=\2', result)

    # Handle count() by converting to sum with implicit bool→int coercion
    # count(i in 1..8)(x[i] > 0) → sum(i in 1..8)(x[i] > 0)
    # MiniZinc does implicit bool2int in arithmetic contexts
    result = re.sub(r'\bcount\s*\(', 'sum(', result)

    # Handle true/false literals
    result = re.sub(r'\btrue\b', 'true', result, flags=re.IGNORECASE)
    result = re.sub(r'\bfalse\b', 'false', result, flags=re.IGNORECASE)

    return result.strip()


def generate_mzn_header(params: Dict) -> List[str]:
    """Generate MiniZinc header with parameters."""
    lines = [
        "% MiniZinc model for 8D unit-sum manifold + Monster primes",
        "% Auto-generated by transpile_to_mzn.py",
        "",
        "% Parameters",
    ]

    scale_n = params.get("scaleN", 100)
    lines.append(f"int: N = {scale_n};  % sum(x[i]) = N (discrete unitary)")

    monster_primes = params.get("monsterPrimes", [2, 3, 5, 7, 11, 13, 17, 19])
    primes_str = ", ".join(str(p) for p in monster_primes)
    lines.append(f"set of int: P = {{ {primes_str} }};  % Monster primes subset")

    lines.extend([
        "",
        "% Decision variables: 8D coordinates",
        "array[1..8] of var 0..N: x;",
        "",
        "% Unit-sum constraint",
        "constraint sum(i in 1..8)(x[i]) = N;",
        "",
    ])

    return lines


def generate_mzn_constraints(constraints: List[Dict]) -> List[str]:
    """Generate MiniZinc constraint declarations."""
    lines = ["% Domain-specific constraints"]

    for c in constraints:
        name = c.get("name", "unnamed")
        expr = c.get("expr", "true")
        notes = c.get("notes", "")

        # Add name annotation as comment
        lines.append(f"% constraint: {name}")

        # Translate expression
        mzn_expr = translate_expr_to_mzn(expr)
        lines.append(f"constraint {mzn_expr};")

        # Add notes as comment if present
        if notes:
            lines.append(f"% {notes}")

        lines.append("")  # Blank line between constraints

    return lines


def generate_mzn_footer(params: Dict) -> List[str]:
    """Generate MiniZinc footer with objective."""
    lines = []

    similarity_obj = params.get("similarityObjective", "none")

    if similarity_obj == "none":
        lines.extend([
            "% No optimization objective",
            "solve satisfy;",
        ])
    elif similarity_obj == "neighbor_distance_min":
        lines.extend([
            "% Minimize neighbor distance (requires adjacency specification)",
            "% var int: total_distance;",
            "% constraint total_distance = ...; % Define based on chunk semantics",
            "% solve minimize total_distance;",
            "solve satisfy;  % Fallback to satisfaction",
        ])
    else:
        lines.extend([
            f"% Objective: {similarity_obj}",
            "solve satisfy;",
        ])

    return lines


def generate_mzn_from_json(json_data: Dict) -> str:
    """Generate complete MiniZinc model from JSON constraints."""
    params = json_data.get("parameters", {})
    constraints = json_data.get("constraints", [])

    lines = []
    lines.extend(generate_mzn_header(params))
    lines.extend(generate_mzn_constraints(constraints))
    lines.extend(generate_mzn_footer(params))

    return "\n".join(lines)


def process_chunk(chunk_id: str, base_dir: Path, output_path: Optional[Path] = None) -> bool:
    """Process a single chunk and generate MiniZinc model."""
    chunks_dir = base_dir / "true-dual-tract" / "chunks"
    json_path = chunks_dir / f"chunk-{chunk_id}.constraints.json"

    if not json_path.exists():
        print(f"Error: JSON file not found: {json_path}", file=sys.stderr)
        return False

    # Read JSON
    try:
        json_data = json.loads(json_path.read_text(encoding="utf-8"))
    except Exception as e:
        print(f"Error reading JSON for chunk {chunk_id}: {e}", file=sys.stderr)
        return False

    # Generate MiniZinc
    mzn_content = generate_mzn_from_json(json_data)

    # Determine output path
    if output_path is None:
        output_path = chunks_dir / f"chunk-{chunk_id}.mzn"

    # Write output
    output_path.write_text(mzn_content, encoding="utf-8")
    print(f"Generated: {output_path}")

    return True


def discover_chunks(base_dir: Path) -> List[str]:
    """Discover all chunk IDs from JSON files."""
    chunks_dir = base_dir / "true-dual-tract" / "chunks"
    ids = []

    for json_file in sorted(chunks_dir.glob("chunk-*.constraints.json")):
        match = re.search(r"chunk-(\d+)\.constraints\.json$", json_file.name)
        if match:
            ids.append(f"{int(match.group(1)):02d}")

    return ids


def main(argv: Optional[List[str]] = None) -> int:
    parser = argparse.ArgumentParser(
        description="Transpile JSON constraint DSL to MiniZinc"
    )

    default_base = Path(__file__).resolve().parents[1]
    parser.add_argument(
        "--base-dir",
        type=Path,
        default=default_base,
        help=f"Base duality directory (default: {default_base})"
    )
    parser.add_argument(
        "--chunk",
        type=str,
        help="Chunk ID to process (e.g., 06)"
    )
    parser.add_argument(
        "--all",
        action="store_true",
        help="Process all discovered chunks"
    )
    parser.add_argument(
        "--output",
        type=Path,
        help="Output path (default: chunk-{id}.mzn in chunks dir)"
    )

    args = parser.parse_args(argv)

    if not args.chunk and not args.all:
        parser.error("Must specify --chunk or --all")

    base_dir = args.base_dir

    if args.all:
        chunk_ids = discover_chunks(base_dir)
        if not chunk_ids:
            print("No chunks discovered", file=sys.stderr)
            return 1

        success_count = 0
        for cid in chunk_ids:
            if process_chunk(cid, base_dir):
                success_count += 1

        print(f"\nProcessed {success_count}/{len(chunk_ids)} chunks successfully")
        return 0 if success_count == len(chunk_ids) else 1

    else:
        # Process single chunk
        chunk_id = f"{int(args.chunk):02d}"
        success = process_chunk(chunk_id, base_dir, args.output)
        return 0 if success else 1


if __name__ == "__main__":
    raise SystemExit(main())
