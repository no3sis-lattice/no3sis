# Phase 9a: Minimal Real Proof - Transpiler Correctness

**Goal**: Prove transpiler correctness for one operator family in one chunk, establishing foundation for full formalization.

**Status**: PLANNING (Phase 6b complete, ready to proceed)

---

## Scope

**Target**: Chunk 06, constraint `balance_internal_external`
- **Operator Family**: `sum` (simplest operator with clear semantics)
- **Constraint**: `sum(i in 1..4)(x[i]) >= sum(i in 5..8)(x[i])`
- **Rationale**: 
  - No nested operators (unlike `abs` which expands to bidirectional constraints)
  - Clear expansion pattern: `sum(i in 1..4)(x[i])` → `x.x1 + x.x2 + x.x3 + x.x4`
  - Already tested via `test_sum_expansion` in test_transpilers.py (passes)

---

## Architecture

### Layer 1: JSON Representation (Source of Truth)
```json
{
  "name": "balance_internal_external",
  "expr": "sum(i in 1..4)(x[i]) >= sum(i in 5..8)(x[i])"
}
```

### Layer 2: Transpiler Output (Programmatic)
```lean
-- Generated by transpile_to_lean.py
def balance_internal_external (x : X8) : Prop :=
  x.x1 + x.x2 + x.x3 + x.x4 >= x.x5 + x.x6 + x.x7 + x.x8
```

### Layer 3: Semantic Interpretation (What it means)
```lean
-- The proposition we claim the transpiler encodes correctly
def balance_internal_external_semantic (x : X8) : Prop :=
  (x.x1 + x.x2 + x.x3 + x.x4 : Nat) >= (x.x5 + x.x6 + x.x7 + x.x8 : Nat)
```

### Layer 4: Correctness Theorem (The Proof Goal)
```lean
-- Prove that transpiler output is semantically equivalent to intended meaning
theorem transpiler_correct_sum_chunk06 :
  ∀ x : X8, balance_internal_external x ↔ balance_internal_external_semantic x := by
  intro x
  -- Proof: Both definitions are syntactically identical
  -- No transformation needed since >= already operates on Nat
  rfl  -- Reflexivity suffices
```

---

## Implementation Plan

### Step 1: Extract Transpiler Logic (15 min)
**File**: `scripts/transpile_to_lean.py`
- Identify `expand_sum()` function (lines ~250-280)
- Document expansion algorithm:
  ```python
  def expand_sum(expr):
      # Pattern: sum(i in START..END)(BODY)
      # Output: BODY[i=START] + BODY[i=START+1] + ... + BODY[i=END]
      # For x[i]: becomes x.x{i} after array_index translation
  ```
- Confirm idempotency: Running twice produces same output

### Step 2: Formalize Expansion in Lean (30 min)
**File**: `formal/Duality/Transpiler/SumExpansion.lean` (new)
```lean
-- Model of sum expansion as a Lean function
def expand_sum_range (start finish : Nat) (body : Nat → Expr) : Expr :=
  match finish - start with
  | 0 => body start
  | n+1 => Expr.add (body start) (expand_sum_range (start+1) finish body)

-- Property: Expansion preserves semantics
theorem sum_expansion_correct (start finish : Nat) (body : Nat → Nat) :
  (List.range' start (finish - start + 1)).sum (fun i => body i) =
  eval_expr (expand_sum_range start finish (fun i => Expr.const (body i))) := by
  sorry  -- Phase 9a goal
```

### Step 3: Connect Transpiler Output to Semantic Meaning (1 hour)
**File**: `formal/Duality/Chunks/Chunk06_Correctness.lean` (new)
```lean
import Duality.Chunks.Chunk06
import Duality.Transpiler.SumExpansion

-- Parse JSON constraint programmatically (metaprogramming)
#eval parse_json_constraint 
  "{\"name\": \"balance_internal_external\", \"expr\": \"sum(i in 1..4)(x[i]) >= sum(i in 5..8)(x[i])\"}"
-- Output: Should produce Expr tree

-- Run transpiler programmatically
#eval transpile_expr "sum(i in 1..4)(x[i]) >= sum(i in 5..8)(x[i])"
-- Output: "x.x1 + x.x2 + x.x3 + x.x4 >= x.x5 + x.x6 + x.x7 + x.x8"

-- Prove equivalence
theorem transpiler_correct_balance_internal_external :
  ∀ x : X8,
    (balance_internal_external x) ↔
    ((x.x1 + x.x2 + x.x3 + x.x4 : Nat) >= (x.x5 + x.x6 + x.x7 + x.x8 : Nat)) := by
  intro x
  rfl  -- Both sides are definitionally equal
```

### Step 4: Generalize to Arbitrary Sum Expressions (2 hours)
**File**: `formal/Duality/Transpiler/Correctness.lean` (new)
```lean
-- General correctness theorem for sum operator
theorem transpiler_correct_sum (expr : JsonConstraint) (h : is_sum_expr expr) :
  ∀ x : X8,
    (eval_transpiled (transpile expr) x) ↔
    (eval_semantic expr x) := by
  sorry  -- Future work: generalize beyond Chunk 06
```

---

## Success Criteria

**Phase 9a Complete** when:
- ✅ One real theorem proven without `sorry`
- ✅ Theorem compiles with `lake build`
- ✅ Proof demonstrates transpiler correctness for sum operator
- ✅ Pattern established for proving other operators (forall, abs, count)

**Estimated Time**: 4-6 hours
- Research Lean metaprogramming: 1-2 hours
- Implementation: 2-3 hours
- Testing and refinement: 1 hour

---

## Future Work (Phase 9b+)

Once `sum` correctness is proven:
1. **abs operator**: Prove bidirectional expansion `abs(x-y) <= k` → `(x:Int)-y <= k ∧ (y:Int)-x <= k`
2. **forall operator**: Prove conjunction expansion `forall(i in S)(P(i))` → `P(s1) ∧ P(s2) ∧ ...`
3. **count operator**: Prove List.sum equivalence `count(i in S)(P(i))` → `List.sum (List.map ...)`
4. **Composition**: Prove correctness when operators nest (e.g., `sum(i in S)(abs(x[i] - y[i]))`)

---

## References

- **Test Coverage**: `test_transpilers.py::TestTranspileToLean::test_sum_expansion` (passing)
- **Transpiler Code**: `scripts/transpile_to_lean.py::expand_sum()` (lines 250-280)
- **Lean Documentation**: [Metaprogramming in Lean 4](https://leanprover.github.io/lean4/doc/metaprogramming.html)
- **Similar Work**: CompCert (compiler correctness), Coq extraction proofs

---

**Next Action**: Begin Step 1 (extract transpiler logic) when Phase 6b approved by stakeholders.
