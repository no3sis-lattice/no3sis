/-
Chunk 06: External Tract: Interface Operator Pipeline
Auto-generated by transpile_to_lean.py
Phase 6b: Added documentation theorems
Phase 9a: Added transpiler correctness integration
-/

import Duality.Base
import Duality.Lemmas
import Duality.Transpiler

namespace Chunk06
open Duality

def domainConstraints (x : X8) : Prop :=
  -- constraint: chunk_06_exists
  (True) ∧
  -- constraint: proof_required
  (True) ∧
  -- constraint: external_min_viable
  (x.x1 + x.x2 + x.x3 >= 30) ∧
  -- constraint: external_reactive_bias
  ((x.x1 + x.x2 + x.x3 + x.x4) >= (x.x5 + x.x6 + x.x7 + x.x8)) ∧
  -- constraint: external_min_per_layer
  ((x.x1 >= 3 ∧ x.x2 >= 3 ∧ x.x3 >= 3 ∧ x.x4 >= 3))

-- Decidability instance (required for computational verification)
instance : Decidable (domainConstraints x) := by
  unfold domainConstraints
  infer_instance

-- Witness (to be injected from MiniZinc solution)
def witness : X8 := ⟨91, 3, 3, 3, 0, 0, 0, 0⟩

theorem witness_valid : unitary witness ∧ domainConstraints witness := by
  decide

theorem exists_solution : ∃ x : X8, unitary x ∧ domainConstraints x :=
  ⟨witness, witness_valid⟩

-- PHASE 6b: Documentation Theorem (Not a Transpiler Correctness Proof)
--
-- NOTE: This is a reflexive documentation theorem (A ↔ A).
-- It documents the correspondence between JSON constraint names and Lean definitions,
-- but does NOT prove transpiler correctness (JSON → Lean equivalence).
--
-- Future work: To prove transpiler correctness, we would need to:
-- 1. Parse JSON constraint expressions in Lean
-- 2. Run the transpiler to generate Lean code
-- 3. Prove transpiler output ≡ handwritten Lean definition
--
-- This would require Lean metaprogramming and is beyond the scope of Phase 6b.
theorem spec_documentation (x : X8) :
  domainConstraints x ↔
  (True ∧  -- chunk_06_exists
   True ∧  -- proof_required
   (x.x1 + x.x2 + x.x3 >= 30) ∧  -- external_min_viable (JSON: x[1] + x[2] + x[3] >= 30)
   (T_ext x >= T_int x) ∧  -- external_reactive_bias (JSON: sum(i in 1..4)(x[i]) >= sum(i in 5..8)(x[i]))
   (x.x1 >= 3 ∧ x.x2 >= 3 ∧ x.x3 >= 3 ∧ x.x4 >= 3))  -- external_min_per_layer (JSON: forall(i in 1..4)(x[i] >= 3))
  := by
  unfold domainConstraints T_ext T_int
  constructor
  · intro h; exact h
  · intro h; exact h

-- PHASE 9a: Transpiler Correctness Integration
--
-- This theorem links the domainConstraints definition to the transpiler correctness proof.
-- It demonstrates that the external_reactive_bias constraint (line 23) matches
-- the transpiler's expected output for the JSON expression:
--   "sum(i in 1..4)(x[i]) >= sum(i in 5..8)(x[i])"
--
-- Key improvement over spec_documentation:
-- - Explicitly references Transpiler.expectedLean_external_reactive_bias
-- - Names the transpiler transformation being validated
-- - Provides foundation for extending to other operators (abs, forall)

-- Helper: Extract the reactive_bias constraint from domainConstraints
def extract_reactive_bias (x : X8) (h : domainConstraints x) :
    (x.x1 + x.x2 + x.x3 + x.x4) >= (x.x5 + x.x6 + x.x7 + x.x8) :=
  h.2.2.2.1

-- Lemma: domainConstraints implies the transpiler's expected semantics
theorem reactive_bias_matches_transpiler_semantics (x : X8) (h : domainConstraints x) :
  Transpiler.expectedLean_external_reactive_bias x := by
  unfold Transpiler.expectedLean_external_reactive_bias
  exact extract_reactive_bias x h

-- Lemma: domainConstraints implies the actual transpiler output
theorem reactive_bias_matches_transpiler_output (x : X8) (h : domainConstraints x) :
  Transpiler.actualTranspilerOutput_external_reactive_bias x := by
  unfold Transpiler.actualTranspilerOutput_external_reactive_bias
  unfold T_ext T_int
  exact extract_reactive_bias x h

-- Main Phase 9a theorem: Prove transpiler correctness for sum operator
-- This is ONE step better than spec_documentation because it:
-- 1. Explicitly names the JSON → Lean transformation
-- 2. Links domainConstraints to transpiler semantics
-- 3. Demonstrates extensible pattern for future work
theorem spec_with_transpiler_proof (x : X8) :
  domainConstraints x →
    Transpiler.expectedLean_external_reactive_bias x ∧
    Transpiler.actualTranspilerOutput_external_reactive_bias x := by
  intro h
  constructor
  · exact reactive_bias_matches_transpiler_semantics x h
  · exact reactive_bias_matches_transpiler_output x h

/-
Phase 9a Achievement:
- Created explicit link between domainConstraints and transpiler definitions
- Proved transpiler output matches semantic intent (not just A ↔ A)
- Zero sorry in transpiler-specific theorems
- Pattern ready for extension to abs and forall operators

Limitations acknowledged:
- Still uses definitional equality (extract from conjunction)
- Only covers one constraint (external_reactive_bias)
- Does not cover forall operator (external_min_per_layer)
- Full JSON parsing deferred to Phase 9b
-/

end Chunk06
